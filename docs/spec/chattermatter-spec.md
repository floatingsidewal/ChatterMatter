# ChatterMatter Format Specification v0.1

## 1. Introduction

ChatterMatter is a format for embedding structured comments and review feedback inside Markdown documents. Comments are encoded as JSON objects inside fenced code blocks with the `chattermatter` language tag, so they:

- Travel with the document (no external service required)
- Degrade gracefully in any Markdown renderer (displayed as inert code blocks)
- Survive every text pipeline that preserves fenced code blocks
- Are machine-readable for tooling, AI systems, and automation

**Design principles:**
- Loss tolerance ‚Äî documents remain valid Markdown regardless of client support
- File-native ‚Äî comments live in (or alongside) the document, not in a platform
- Typed intent ‚Äî comment types are machine-readable, not ad-hoc prefixes
- AI-native ‚Äî designed as both input and output for AI document reviewers

## 2. Terminology

- **Block** ‚Äî a single ChatterMatter JSON object inside a fenced code block.
- **Document** ‚Äî the Markdown file being annotated.
- **Anchor** ‚Äî the mechanism that binds a block to a location in the document.
- **Thread** ‚Äî a tree of blocks connected by `parent_id` references.
- **Client** ‚Äî any tool that reads, writes, or renders ChatterMatter blocks.
- **Sidecar file** ‚Äî a companion file that contains ChatterMatter blocks for a separate Markdown document.

The key words "MUST", "MUST NOT", "SHOULD", "SHOULD NOT", and "MAY" are used as defined in RFC 2119.

## 3. Encoding

### 3.1 Fenced Code Block (Primary)

A ChatterMatter block is a fenced code block with the language tag `chattermatter` containing exactly one JSON object:

````markdown
```chattermatter
{
  "id": "a1b2c3",
  "type": "comment",
  "author": "alice",
  "timestamp": "2026-02-20T10:30:00Z",
  "anchor": { "type": "text", "exact": "introduces the idea" },
  "content": "Consider strengthening this opening.",
  "status": "open"
}
```
````

Each fenced code block MUST contain exactly one JSON object. Multiple blocks are represented as multiple fenced code blocks.

### 3.2 HTML Comment Encoding (Secondary)

For scenarios where code blocks are undesirable, blocks MAY be encoded as HTML comments:

```html
<!--chattermatter {"id":"a1b2c3","type":"comment",...} -->
```

**Constraint:** HTML comment encoding MUST NOT be used if the JSON payload contains the string `-->`. Clients encountering `-->` inside an HTML-comment-encoded block MUST treat it as malformed and ignore it.

### 3.3 JSON Conformance

All JSON MUST conform to RFC 8259 (the JSON standard). Specifically:

- All strings MUST be double-quoted
- No comments are permitted inside JSON
- No trailing commas
- No unquoted keys
- Encoding MUST be UTF-8

JSON5 features are NOT permitted.

## 4. Block Schema

### 4.1 Required Fields

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique identifier for this block within the document |
| `type` | string | One of the defined type values (see ¬ß4.3) |
| `content` | string | The comment text (Markdown permitted). MAY be empty for `reaction` type |

### 4.2 Optional Fields

| Field | Type | Description |
|-------|------|-------------|
| `author` | string | Display name or identifier of the comment author |
| `timestamp` | string | ISO 8601 datetime (e.g., `"2026-02-20T10:30:00Z"`) |
| `anchor` | object | Location binding (see ¬ß5). If omitted, the block is a document-level comment |
| `parent_id` | string | ID of the parent block, creating a thread (see ¬ß6) |
| `status` | string | `"open"` or `"resolved"`. Defaults to `"open"` if omitted |
| `metadata` | object | Open object for extensions (see ¬ß9) |
| `spec_version` | string | The spec version this block conforms to (e.g., `"0.1"`) |

### 4.3 Type Enum

The `type` field MUST be one of the following values:

| Type | Purpose | Requirements |
|------|---------|-------------|
| `comment` | General feedback or observation | `content` is the comment text |
| `question` | Request for clarification; expects a reply | `content` is the question text |
| `suggestion` | A proposed text change | MUST include a `suggestion` object (see ¬ß4.4) |
| `ai_feedback` | Feedback generated by an AI system | SHOULD include AI metadata (see ¬ß4.5) |
| `reaction` | A lightweight response (emoji, +1) | `content` MUST be a single Unicode emoji or a short predefined string (see ¬ß4.6) |

**Rationale for excluded types:**
- `thread` ‚Äî Threads are an emergent structure from `parent_id` references, not a block type.
- `resolution` ‚Äî Resolution is handled by the `status` field on any block. A reply explaining why a thread was resolved is a `comment` with the parent thread's `status` set to `"resolved"`.

### 4.4 Suggestion Format

Blocks with `"type": "suggestion"` MUST include a `suggestion` object with the proposed change:

```json
{
  "id": "s1",
  "type": "suggestion",
  "author": "bob",
  "anchor": { "type": "text", "exact": "introduces the idea" },
  "content": "This phrasing is vague ‚Äî consider being more specific.",
  "suggestion": {
    "original": "introduces the idea",
    "replacement": "introduces the core concept of portable document review"
  },
  "status": "open"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `suggestion.original` | string | The exact text to be replaced. SHOULD match `anchor.exact` when the anchor type is `text` |
| `suggestion.replacement` | string | The proposed replacement text |

The `content` field provides the rationale for the suggestion. The `suggestion` object provides the machine-actionable diff.

### 4.5 AI Feedback Metadata

Blocks with `"type": "ai_feedback"` SHOULD include AI-specific fields in `metadata`:

```json
{
  "id": "ai-1",
  "type": "ai_feedback",
  "anchor": { "type": "heading", "text": "Rollback Plan" },
  "content": "This section describes how to roll back the database migration but doesn't address rolling back the API changes.",
  "metadata": {
    "model": "claude-opus-4-6",
    "confidence": "high",
    "category": "completeness"
  }
}
```

Recommended metadata fields for AI feedback:

| Field | Type | Description |
|-------|------|-------------|
| `metadata.model` | string | The AI model identifier |
| `metadata.confidence` | string | `"high"`, `"medium"`, or `"low"` |
| `metadata.category` | string | Freeform category (e.g., `"completeness"`, `"clarity"`, `"consistency"`, `"accuracy"`) |

These fields are recommendations, not requirements. Clients MUST NOT reject blocks that lack them.

### 4.6 Reaction Constraints

Blocks with `"type": "reaction"` are lightweight signals. The `content` field MUST be one of:

- A single Unicode emoji (e.g., `"üëç"`, `"‚ù§Ô∏è"`, `"üéâ"`)
- A short predefined string: `"+1"`, `"-1"`, `"agree"`, `"disagree"`

Reactions MUST have a `parent_id` ‚Äî they are always responses to another block, never standalone. The `anchor` field is omitted for reactions (they inherit the parent's anchor context).

## 5. Anchoring

Anchors bind a block to a specific location in the document. The `anchor` object has a required `type` field and type-specific properties.

### 5.1 Text Quote Anchor

Matches a specific text passage in the document.

```json
{
  "type": "text",
  "exact": "introduces the idea",
  "context_before": "The opening paragraph ",
  "context_after": " and sets the tone"
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | `"text"` | Yes | |
| `exact` | string | Yes | The exact text to match |
| `context_before` | string | No | Text immediately preceding the match (for disambiguation) |
| `context_after` | string | No | Text immediately following the match (for disambiguation) |

**Resolution rules:**

1. Search the document for occurrences of `exact`.
2. If `context_before` and/or `context_after` are provided, filter matches to those where the surrounding text matches.
3. If exactly one match remains, use it.
4. If multiple matches remain after applying context, use the **first** match in document order.
5. If zero matches are found, the anchor is **unresolved** (see ¬ß5.5).

### 5.2 Heading Anchor

Matches a Markdown heading by its text content.

```json
{
  "type": "heading",
  "text": "Rollback Plan",
  "level": 3
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | `"heading"` | Yes | |
| `text` | string | Yes | The heading text (without `#` prefix) |
| `level` | integer | No | Heading level (1‚Äì6). Used for disambiguation if multiple headings share the same text |

If multiple headings match, use the first match in document order.

### 5.3 Block Index Anchor

References a Markdown block by its zero-indexed position among top-level blocks.

```json
{
  "type": "block_index",
  "index": 5
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `type` | `"block_index"` | Yes | |
| `index` | integer | Yes | Zero-based index of the target block |

**Fragility warning:** Block indices shift when blocks are inserted or deleted above the target. Clients SHOULD treat block index anchors as a **hint** and attempt to validate them against nearby content. When authoring blocks, clients SHOULD prefer text or heading anchors over block index anchors.

Block index anchors are best used in combination with other anchor types as a fallback (see ¬ß5.4).

### 5.4 Composite Anchors

A block MAY include multiple anchor strategies for resilience. The `anchor` object MAY contain a `fallback` field:

```json
{
  "type": "text",
  "exact": "introduces the idea",
  "fallback": {
    "type": "block_index",
    "index": 3
  }
}
```

Clients SHOULD attempt the primary anchor first, then the fallback if the primary is unresolved.

### 5.5 Anchor Failure Behavior

When a block's anchor cannot be resolved (no match found, index out of bounds):

1. Clients MUST NOT discard the block.
2. Clients MUST mark the block as **orphaned** (anchor unresolved).
3. Clients SHOULD still display orphaned blocks ‚Äî in a sidebar, at the end of the document, or in a dedicated "orphaned comments" section.
4. Clients MAY offer the user an option to re-anchor orphaned blocks.

### 5.6 Character Offset Anchors

Character offsets (`"type": "offset"`) are NOT part of v0.1. They are fragile ‚Äî any edit to the document shifts all subsequent offsets. They may be introduced in a future version with appropriate safeguards.

### 5.7 Anchor Preference Order

When authoring blocks, clients SHOULD prefer anchor types in this order:

1. **Text quote** ‚Äî most resilient to document edits
2. **Heading** ‚Äî stable unless the heading text is changed
3. **Block index** ‚Äî fragile; use as fallback only

## 6. Threading

Blocks form threads via the `parent_id` field. A block without a `parent_id` is a **root** block. A block with a `parent_id` is a **reply** to the referenced block.

```json
{"id": "c1", "type": "comment", "content": "This section is unclear."}
{"id": "c2", "type": "comment", "parent_id": "c1", "content": "Can you be more specific?"}
{"id": "c3", "type": "comment", "parent_id": "c1", "content": "I agree ‚Äî the third paragraph especially."}
```

This creates a tree:
```
c1 (root)
‚îú‚îÄ‚îÄ c2 (reply)
‚îî‚îÄ‚îÄ c3 (reply)
```

**Rules:**

- `parent_id` MUST reference an `id` that exists in the same document (or sidecar scope ‚Äî see ¬ß7).
- **Orphaned threads:** If `parent_id` references a non-existent ID, clients MUST treat the block as a root block and SHOULD warn the user.
- **Circular references:** If a cycle is detected (e.g., `c1.parent_id = "c2"`, `c2.parent_id = "c1"`), clients MUST treat all blocks in the cycle as root blocks and SHOULD warn the user.
- **Display ordering:** Within a thread, blocks SHOULD be displayed in `timestamp` order. If timestamps are absent, document order (the order blocks appear in the file) is used.

### 6.1 Resolving Threads

To resolve a thread, set `"status": "resolved"` on the root block. Clients SHOULD visually collapse resolved threads. A reply explaining the resolution is encouraged:

```json
{"id": "c1", "type": "question", "content": "Why is this approach used?", "status": "resolved"}
{"id": "c4", "type": "comment", "parent_id": "c1", "content": "Explained in the new section on trade-offs."}
```

## 7. Document Modes

ChatterMatter supports two placement modes. Both use the same JSON format and anchor model.

### 7.1 Inline Mode

Blocks are embedded directly in the `.md` file, interspersed with the document content:

```markdown
# Introduction

This paragraph introduces the idea and sets the tone.

‚Äã```chattermatter
{
  "id": "c1",
  "type": "comment",
  "anchor": { "type": "text", "exact": "introduces the idea" },
  "content": "Consider strengthening this opening."
}
‚Äã```

The next section continues...
```

**Best for:** Self-contained documents where the review history is part of the deliverable (ADRs, RFCs, design docs).

### 7.2 Sidecar Mode

Blocks live in a companion file alongside the document:

```
proposal.md           ‚Üê clean Markdown, no ChatterMatter blocks
proposal.md.chatter   ‚Üê all ChatterMatter blocks, anchored to proposal.md
```

The sidecar file uses the `.chatter` extension appended to the full filename. It contains one or more ChatterMatter fenced code blocks, in standard Markdown format.

**Best for:**
- Published documents where the review layer should be separate
- Scenarios requiring access control (public document, private review)
- Users who want zero-impact on the source file

**Rules for sidecar mode:**

- The sidecar file MUST be named `<original-filename>.chatter` (e.g., `proposal.md.chatter`).
- Anchors in the sidecar file reference locations in the associated document, not the sidecar itself.
- A document MAY have both inline blocks and a sidecar file. Clients MUST merge both sets, preferring the sidecar version if the same `id` appears in both.
- The sidecar file is itself valid Markdown (it contains fenced code blocks).

### 7.3 Scope and Namespacing

All blocks in a document (inline) or a document-sidecar pair share a single **conversation namespace**:

- IDs MUST be unique within this namespace.
- `parent_id` references MUST resolve within this namespace.
- Cross-document references (a block in document A referencing a block in document B) are NOT supported in v0.1.

## 8. Block Placement and Ordering

### 8.1 Inline Mode Placement

In inline mode, ChatterMatter blocks MAY appear anywhere in the document ‚Äî between paragraphs, at the end, or grouped in a dedicated section. Clients MUST NOT assume blocks are positioned near their anchors.

### 8.2 Ordering Semantics

**Document position** of blocks is irrelevant for display purposes. Clients MUST derive display order from:

1. **Anchor location** ‚Äî blocks are displayed at the document location their anchor resolves to.
2. **Thread structure** ‚Äî threaded blocks are grouped under their root.
3. **Timestamp** ‚Äî within a thread or anchor location, blocks are ordered by `timestamp` (ascending). If timestamps are absent, document order is used as a tiebreaker.

## 9. Metadata and Extensibility

The `metadata` field is an open JSON object for tool-specific extensions:

```json
{
  "id": "c1",
  "type": "comment",
  "content": "Needs rewording.",
  "metadata": {
    "priority": "high",
    "reviewer_role": "legal",
    "custom_field": "any value"
  }
}
```

**Rules:**

- Clients MUST ignore unknown fields at the top level and inside `metadata`.
- **Round-trip preservation:** Clients that read and rewrite ChatterMatter blocks MUST preserve all fields they do not understand, including unknown top-level fields and unknown `metadata` properties. This ensures that data written by one tool is not silently dropped by another.
- Clients MUST NOT reject a block because of unknown fields.

## 10. IDs

### 10.1 Format

Block IDs MUST be unique within the document namespace (see ¬ß7.3). To ensure uniqueness in multi-author scenarios:

- IDs SHOULD be UUIDs (v4) or ULIDs.
- Short sequential IDs (e.g., `"c1"`, `"c2"`) are permitted for single-author documents but are NOT RECOMMENDED for collaborative use due to collision risk.
- IDs MUST be non-empty strings containing only printable ASCII characters (U+0021 to U+007E).

### 10.2 Duplicate ID Handling

If a client encounters two blocks with the same `id` in a single document namespace:

1. The client SHOULD warn the user.
2. The client SHOULD use the **last** occurrence (in document order) as authoritative.
3. Clients MUST NOT silently merge or discard duplicate blocks without warning.

## 11. Spec Version

The optional `spec_version` field indicates which version of this specification the block was authored against.

- If present, it MUST be a semver-compatible string (e.g., `"0.1"`, `"1.0"`).
- A document MAY contain blocks with different `spec_version` values. Clients MUST handle mixed versions gracefully ‚Äî unknown fields from newer versions are preserved per ¬ß9.
- If `spec_version` is absent, clients SHOULD assume the latest version they support.

## 12. Error Handling

Clients MUST handle the following error conditions:

| Condition | Behavior |
|-----------|----------|
| **Malformed JSON** inside a `chattermatter` fence | MUST ignore the block. SHOULD warn the user. The block is treated as a plain code block |
| **Missing required field** (`id`, `type`, or `content`) | MUST ignore the block. SHOULD warn the user |
| **Unknown `type` value** | MUST preserve the block. SHOULD display it as a generic comment |
| **Duplicate IDs** | See ¬ß10.2 |
| **Orphaned `parent_id`** | Treat as root block (see ¬ß6) |
| **Circular thread references** | Treat all blocks in the cycle as root blocks (see ¬ß6) |
| **Unresolved anchor** | Mark as orphaned; still display (see ¬ß5.5) |
| **HTML comment block containing `-->`** | MUST ignore the block |

The guiding principle is: **never lose data silently**. Warn users about problems, but preserve and display blocks whenever possible.

## 13. What This Spec Does NOT Define

This specification intentionally excludes:

- **Rendering** ‚Äî how clients visually present blocks (sidebar, overlay, inline highlights)
- **Authentication** ‚Äî how `author` identity is verified
- **Permissions** ‚Äî who can add, edit, or resolve blocks
- **Real-time collaboration** ‚Äî conflict resolution for simultaneous editing
- **Transport** ‚Äî how files are shared between users
- **Workflow** ‚Äî reviewer assignment, approval chains, deadlines

These are concerns for tools and platforms built on top of the format.

## 14. Future Directions

The following features are under consideration for future versions:

- **Character offset anchors** with drift-correction algorithms
- **Regex anchors** for pattern-based matching
- **Block-level suggestions** for multi-paragraph replacements
- **Document-level meta block** (e.g., `"type": "meta"`) for document-wide settings
- **Cross-document references** for linking discussions across files
- **Approval workflows** ‚Äî formal sign-off semantics
- **Merge strategies** for resolving ChatterMatter conflicts in version control

## Appendix A: Complete Block Example

```json
{
  "id": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
  "type": "suggestion",
  "author": "bob",
  "timestamp": "2026-02-20T14:22:00Z",
  "anchor": {
    "type": "text",
    "exact": "the system will automatically retry",
    "context_before": "If the request fails, ",
    "context_after": " up to three times.",
    "fallback": {
      "type": "heading",
      "text": "Error Handling"
    }
  },
  "parent_id": null,
  "status": "open",
  "content": "This should specify the backoff strategy ‚Äî constant, linear, or exponential?",
  "suggestion": {
    "original": "the system will automatically retry",
    "replacement": "the system will automatically retry with exponential backoff (1s, 2s, 4s)"
  },
  "metadata": {
    "reviewer_role": "backend-eng"
  },
  "spec_version": "0.1"
}
```

## Appendix B: Minimal Valid Block

```json
{
  "id": "1",
  "type": "comment",
  "content": "This document needs a conclusion."
}
```
